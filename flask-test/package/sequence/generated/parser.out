Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement
Rule 2     programme -> statement programme
Rule 3     statement -> for
Rule 4     statement -> expression ;
Rule 5     for -> FOR ( assign ; eval ; assign ) { programme }
Rule 6     expression -> section
Rule 7     expression -> pause
Rule 8     assign -> VAR = number
Rule 9     calc -> data OPP data
Rule 10    eval -> data EVAL_OP data
Rule 11    number -> data
Rule 12    number -> calc
Rule 13    data -> NUMBER
Rule 14    data -> VAR
Rule 15    section -> CUBE number
Rule 16    section -> FACE number number
Rule 17    section -> SQUARE number number number
Rule 18    section -> LEDSTRIP number number number number
Rule 19    section -> LED number number number number number
Rule 20    pause -> DELAY number

Terminals, with rules where they appear

(                    : 5
)                    : 5
;                    : 4 5 5
=                    : 8
CUBE                 : 15
DELAY                : 20
EVAL_OP              : 10
FACE                 : 16
FOR                  : 5
LED                  : 19
LEDSTRIP             : 18
NUMBER               : 13
OPP                  : 9
SQUARE               : 17
VAR                  : 8 14
error                : 
{                    : 5
}                    : 5

Nonterminals, with rules where they appear

assign               : 5 5
calc                 : 12
data                 : 9 9 10 10 11
eval                 : 5
expression           : 4
for                  : 3
number               : 8 15 16 16 17 17 17 18 18 18 18 19 19 19 19 19 20
pause                : 7
programme            : 2 5 0
section              : 6
statement            : 1 2

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . for
    (4) statement -> . expression ;
    (5) for -> . FOR ( assign ; eval ; assign ) { programme }
    (6) expression -> . section
    (7) expression -> . pause
    (15) section -> . CUBE number
    (16) section -> . FACE number number
    (17) section -> . SQUARE number number number
    (18) section -> . LEDSTRIP number number number number
    (19) section -> . LED number number number number number
    (20) pause -> . DELAY number

    FOR             shift and go to state 5
    CUBE            shift and go to state 8
    FACE            shift and go to state 9
    SQUARE          shift and go to state 10
    LEDSTRIP        shift and go to state 11
    LED             shift and go to state 12
    DELAY           shift and go to state 13

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    for                            shift and go to state 3
    expression                     shift and go to state 4
    section                        shift and go to state 6
    pause                          shift and go to state 7

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement .
    (2) programme -> statement . programme
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . for
    (4) statement -> . expression ;
    (5) for -> . FOR ( assign ; eval ; assign ) { programme }
    (6) expression -> . section
    (7) expression -> . pause
    (15) section -> . CUBE number
    (16) section -> . FACE number number
    (17) section -> . SQUARE number number number
    (18) section -> . LEDSTRIP number number number number
    (19) section -> . LED number number number number number
    (20) pause -> . DELAY number

    $end            reduce using rule 1 (programme -> statement .)
    }               reduce using rule 1 (programme -> statement .)
    FOR             shift and go to state 5
    CUBE            shift and go to state 8
    FACE            shift and go to state 9
    SQUARE          shift and go to state 10
    LEDSTRIP        shift and go to state 11
    LED             shift and go to state 12
    DELAY           shift and go to state 13

    statement                      shift and go to state 2
    programme                      shift and go to state 14
    for                            shift and go to state 3
    expression                     shift and go to state 4
    section                        shift and go to state 6
    pause                          shift and go to state 7

state 3

    (3) statement -> for .

    FOR             reduce using rule 3 (statement -> for .)
    CUBE            reduce using rule 3 (statement -> for .)
    FACE            reduce using rule 3 (statement -> for .)
    SQUARE          reduce using rule 3 (statement -> for .)
    LEDSTRIP        reduce using rule 3 (statement -> for .)
    LED             reduce using rule 3 (statement -> for .)
    DELAY           reduce using rule 3 (statement -> for .)
    $end            reduce using rule 3 (statement -> for .)
    }               reduce using rule 3 (statement -> for .)


state 4

    (4) statement -> expression . ;

    ;               shift and go to state 15


state 5

    (5) for -> FOR . ( assign ; eval ; assign ) { programme }

    (               shift and go to state 16


state 6

    (6) expression -> section .

    ;               reduce using rule 6 (expression -> section .)


state 7

    (7) expression -> pause .

    ;               reduce using rule 7 (expression -> pause .)


state 8

    (15) section -> CUBE . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 17
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 9

    (16) section -> FACE . number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 22
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 10

    (17) section -> SQUARE . number number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 23
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 11

    (18) section -> LEDSTRIP . number number number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 24
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 12

    (19) section -> LED . number number number number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 25
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 13

    (20) pause -> DELAY . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 26
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 14

    (2) programme -> statement programme .

    $end            reduce using rule 2 (programme -> statement programme .)
    }               reduce using rule 2 (programme -> statement programme .)


state 15

    (4) statement -> expression ; .

    FOR             reduce using rule 4 (statement -> expression ; .)
    CUBE            reduce using rule 4 (statement -> expression ; .)
    FACE            reduce using rule 4 (statement -> expression ; .)
    SQUARE          reduce using rule 4 (statement -> expression ; .)
    LEDSTRIP        reduce using rule 4 (statement -> expression ; .)
    LED             reduce using rule 4 (statement -> expression ; .)
    DELAY           reduce using rule 4 (statement -> expression ; .)
    $end            reduce using rule 4 (statement -> expression ; .)
    }               reduce using rule 4 (statement -> expression ; .)


state 16

    (5) for -> FOR ( . assign ; eval ; assign ) { programme }
    (8) assign -> . VAR = number

    VAR             shift and go to state 28

    assign                         shift and go to state 27

state 17

    (15) section -> CUBE number .

    ;               reduce using rule 15 (section -> CUBE number .)


state 18

    (11) number -> data .
    (9) calc -> data . OPP data

    ;               reduce using rule 11 (number -> data .)
    NUMBER          reduce using rule 11 (number -> data .)
    VAR             reduce using rule 11 (number -> data .)
    )               reduce using rule 11 (number -> data .)
    OPP             shift and go to state 29


state 19

    (12) number -> calc .

    ;               reduce using rule 12 (number -> calc .)
    NUMBER          reduce using rule 12 (number -> calc .)
    VAR             reduce using rule 12 (number -> calc .)
    )               reduce using rule 12 (number -> calc .)


state 20

    (13) data -> NUMBER .

    OPP             reduce using rule 13 (data -> NUMBER .)
    ;               reduce using rule 13 (data -> NUMBER .)
    NUMBER          reduce using rule 13 (data -> NUMBER .)
    VAR             reduce using rule 13 (data -> NUMBER .)
    )               reduce using rule 13 (data -> NUMBER .)
    EVAL_OP         reduce using rule 13 (data -> NUMBER .)


state 21

    (14) data -> VAR .

    OPP             reduce using rule 14 (data -> VAR .)
    ;               reduce using rule 14 (data -> VAR .)
    NUMBER          reduce using rule 14 (data -> VAR .)
    VAR             reduce using rule 14 (data -> VAR .)
    )               reduce using rule 14 (data -> VAR .)
    EVAL_OP         reduce using rule 14 (data -> VAR .)


state 22

    (16) section -> FACE number . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 30
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 23

    (17) section -> SQUARE number . number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 31
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 24

    (18) section -> LEDSTRIP number . number number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 32
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 25

    (19) section -> LED number . number number number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 33
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 26

    (20) pause -> DELAY number .

    ;               reduce using rule 20 (pause -> DELAY number .)


state 27

    (5) for -> FOR ( assign . ; eval ; assign ) { programme }

    ;               shift and go to state 34


state 28

    (8) assign -> VAR . = number

    =               shift and go to state 35


state 29

    (9) calc -> data OPP . data
    (13) data -> . NUMBER
    (14) data -> . VAR

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    data                           shift and go to state 36

state 30

    (16) section -> FACE number number .

    ;               reduce using rule 16 (section -> FACE number number .)


state 31

    (17) section -> SQUARE number number . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 37
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 32

    (18) section -> LEDSTRIP number number . number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 38
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 33

    (19) section -> LED number number . number number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 39
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 34

    (5) for -> FOR ( assign ; . eval ; assign ) { programme }
    (10) eval -> . data EVAL_OP data
    (13) data -> . NUMBER
    (14) data -> . VAR

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    eval                           shift and go to state 40
    data                           shift and go to state 41

state 35

    (8) assign -> VAR = . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 42
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 36

    (9) calc -> data OPP data .

    ;               reduce using rule 9 (calc -> data OPP data .)
    NUMBER          reduce using rule 9 (calc -> data OPP data .)
    VAR             reduce using rule 9 (calc -> data OPP data .)
    )               reduce using rule 9 (calc -> data OPP data .)


state 37

    (17) section -> SQUARE number number number .

    ;               reduce using rule 17 (section -> SQUARE number number number .)


state 38

    (18) section -> LEDSTRIP number number number . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 43
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 39

    (19) section -> LED number number number . number number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 44
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 40

    (5) for -> FOR ( assign ; eval . ; assign ) { programme }

    ;               shift and go to state 45


state 41

    (10) eval -> data . EVAL_OP data

    EVAL_OP         shift and go to state 46


state 42

    (8) assign -> VAR = number .

    ;               reduce using rule 8 (assign -> VAR = number .)
    )               reduce using rule 8 (assign -> VAR = number .)


state 43

    (18) section -> LEDSTRIP number number number number .

    ;               reduce using rule 18 (section -> LEDSTRIP number number number number .)


state 44

    (19) section -> LED number number number number . number
    (11) number -> . data
    (12) number -> . calc
    (13) data -> . NUMBER
    (14) data -> . VAR
    (9) calc -> . data OPP data

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    number                         shift and go to state 47
    data                           shift and go to state 18
    calc                           shift and go to state 19

state 45

    (5) for -> FOR ( assign ; eval ; . assign ) { programme }
    (8) assign -> . VAR = number

    VAR             shift and go to state 28

    assign                         shift and go to state 48

state 46

    (10) eval -> data EVAL_OP . data
    (13) data -> . NUMBER
    (14) data -> . VAR

    NUMBER          shift and go to state 20
    VAR             shift and go to state 21

    data                           shift and go to state 49

state 47

    (19) section -> LED number number number number number .

    ;               reduce using rule 19 (section -> LED number number number number number .)


state 48

    (5) for -> FOR ( assign ; eval ; assign . ) { programme }

    )               shift and go to state 50


state 49

    (10) eval -> data EVAL_OP data .

    ;               reduce using rule 10 (eval -> data EVAL_OP data .)


state 50

    (5) for -> FOR ( assign ; eval ; assign ) . { programme }

    {               shift and go to state 51


state 51

    (5) for -> FOR ( assign ; eval ; assign ) { . programme }
    (1) programme -> . statement
    (2) programme -> . statement programme
    (3) statement -> . for
    (4) statement -> . expression ;
    (5) for -> . FOR ( assign ; eval ; assign ) { programme }
    (6) expression -> . section
    (7) expression -> . pause
    (15) section -> . CUBE number
    (16) section -> . FACE number number
    (17) section -> . SQUARE number number number
    (18) section -> . LEDSTRIP number number number number
    (19) section -> . LED number number number number number
    (20) pause -> . DELAY number

    FOR             shift and go to state 5
    CUBE            shift and go to state 8
    FACE            shift and go to state 9
    SQUARE          shift and go to state 10
    LEDSTRIP        shift and go to state 11
    LED             shift and go to state 12
    DELAY           shift and go to state 13

    programme                      shift and go to state 52
    statement                      shift and go to state 2
    for                            shift and go to state 3
    expression                     shift and go to state 4
    section                        shift and go to state 6
    pause                          shift and go to state 7

state 52

    (5) for -> FOR ( assign ; eval ; assign ) { programme . }

    }               shift and go to state 53


state 53

    (5) for -> FOR ( assign ; eval ; assign ) { programme } .

    FOR             reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    CUBE            reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    FACE            reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    SQUARE          reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    LEDSTRIP        reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    LED             reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    DELAY           reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    $end            reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)
    }               reduce using rule 5 (for -> FOR ( assign ; eval ; assign ) { programme } .)

